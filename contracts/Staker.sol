// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./Math.sol";

import "hardhat/console.sol";

/// @title Synthetix Staking Rewards Contract
/// @author Nika Khachiashvili
/// @notice A contract that allows users to stake ETH and earn rewards based on a specified reward rate and duration.
contract Staker is Ownable {
    event Stake(address indexed staker, uint amount, uint timestamp);
    event Withdraw(address indexed staker, uint amount, uint timestamp);

    /// @dev Immutable reference to the rewards token contract.
    IERC20 public immutable rewardsToken;

    /// @dev Contract constructor.
    /// @param _rewardsToken The address of the ERC20 token contract.
    constructor(address _rewardsToken) {
        rewardsToken = IERC20(_rewardsToken);
    }

    uint public totalRewardsToGive; /// @dev Total Rewards that will be given
    uint public duration; /// @dev Duration of Rewards Given
    uint public finishAt; /// @dev End of Giving Rewards
    uint public rewardRate; /// @dev Amount of rewards to give / duration

    uint public totalStaked; /// @dev Total amount of tokens staked

    mapping(address => uint) public stakedBalanceOf; /// @dev Amount of token staked by users
    mapping(address => uint) public userRewardPerTokenPaid; /// @dev User Reward Per Token Paid
    mapping(address => uint) public userRewards; /// @dev Rewards earned by users

    uint public rewardPerToken; /// @dev Reward per token
    uint public lastUpdateTime; /// @dev Last timestamp when someone staked or withdrew

    /// @dev Sets the rewards for the staking contract.
    /// @param _amount The amount of rewards to be given.
    /// @param _duration The duration for which the rewards will be given.
    function setRewards(uint _amount, uint _duration) external onlyOwner {
        require(finishAt < block.timestamp); /// @dev Make sure contract isn't giving rewards anymore
        require(_amount > 0); /// @dev Make sure rewards amount is more than 0
        require(_duration > 0); /// @dev Make sure rewards duration is more than 0
        require(rewardsToken.balanceOf(address(this)) >= _amount); /// @dev Make sure the contract has enough balance of rewards
        duration = _duration;
        finishAt = block.timestamp + _duration;
        rewardRate = _amount / _duration;
        lastUpdateTime = block.timestamp;
        totalRewardsToGive = _amount;
    }

    /// @dev Allows users to stake tokens and earn rewards.
    function stake() external payable {
        require(stakedBalanceOf[msg.sender] == 0); /// @dev Make sure user hasn't already staked
        require(msg.value > 0); /// @dev Make sure user stakes more than 0 ETH
        require(block.timestamp < finishAt); /// @dev Make sure the contract is still giving rewards

        /// @dev If total stake is 0, new rewardPerToken or userRewardPerTokenPaid will be still 0
        /// @dev and this statements avoid division by 0
        if (totalStaked != 0) {
            /// @dev Updating the variables as the total staked balance changes
            rewardPerToken +=
                ((rewardRate * (_lastApplicableTime() - lastUpdateTime)) *
                    1e18) /
                totalStaked;
            userRewardPerTokenPaid[msg.sender] = rewardPerToken;
        }
        totalStaked += msg.value;
        stakedBalanceOf[msg.sender] = msg.value;
        lastUpdateTime = block.timestamp;
        emit Stake(msg.sender, msg.value, block.timestamp);
    }

    /// @dev Allows users to withdraw their staked tokens and claim their rewards.
    function withdraw() external {
        require(stakedBalanceOf[msg.sender] != 0); /// @dev Make sure user has staked some amount
        uint stakedAmount = stakedBalanceOf[msg.sender];
        /// @dev Update the rewardPerToken as the total staked balance changes
        rewardPerToken +=
            ((rewardRate * (_lastApplicableTime() - lastUpdateTime)) * 1e18) /
            totalStaked;
        /// @dev Update the rewards generated by user in time from staking to withdrawing
        uint rewards = (stakedAmount *
            (rewardPerToken - userRewardPerTokenPaid[msg.sender])) / 1e18;
        /// @dev Update the userRewardPerTokenPaid[msg.sender] as the total staked balance changes
        userRewardPerTokenPaid[msg.sender] = rewardPerToken;
        stakedBalanceOf[msg.sender] = 0;
        totalStaked -= stakedAmount;
        lastUpdateTime = _lastApplicableTime();
        userRewards[msg.sender] += rewards; /// @dev Storing rewards in mapping which than can be taken by getRewards()
        emit Withdraw(msg.sender, stakedAmount, block.timestamp);
    }

    /// @dev When calculating rewards, we want to don't want to include the current timestamp
    /// @dev in the calculations if the contract isn't giving out rewards anymore.
    /// @dev Returns the last applicable time based on the current time and the finish time of giving rewards.
    /// @return The last applicable time.
    function _lastApplicableTime() private view returns (uint) {
        return Math.min(block.timestamp, finishAt);
    }

    /// @dev Allows users to claim their earned rewards.
    function getRewards() external {
        require(userRewards[msg.sender] != 0); /// @dev Make sure user has rewards more than 0
        uint rewards = userRewards[msg.sender];
        userRewards[msg.sender] = 0;
        rewardsToken.transfer(msg.sender, rewards);
    }
}
